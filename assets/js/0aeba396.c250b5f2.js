"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[452],{8229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>f,default:()=>k,frontMatter:()=>y,metadata:()=>b,toc:()=>P});var r=t(7896),a=t(2784),o=t(876),i=t(9979),s=t(1908);class l{cells=[];constructor(e,n,t,r,a){void 0===t&&(t=1);for(let o=0;o<t;o++){const i=s.Z.from(n.map((e=>[e.x,e.y]))).voronoi([0,0,r,a]);this.cells=n.map(((n,t)=>{const r=i.cellPolygon(t);return{site:n,polygon:r?r.map((n=>{let[t,r]=n;return e.createVector(t,r)})):[]}})),o<t-1&&(n=this.cells.map((n=>this.centroid(e,n.polygon))))}}centroid(e,n){let t=0,r=0;for(let a of n)t+=a.x,r+=a.y;return e.createVector(t/n.length,r/n.length)}}const h=(0,a.lazy)((()=>t.e(291).then(t.t.bind(t,2291,23)))),p=e=>n=>{const{shape:t,noiseSeed:r,width:a,height:o}=e,i=[];for(let e=0;e<1e3;e++)i.push(n.createVector(Math.random()*a,Math.random()*o));(e=>{const{scale:t,width:a,height:o}=e;let i=n.createImage(a,o);n.noiseSeed(r),i.loadPixels();for(let r=0;r<i.width;r++)for(let e=0;e<i.height;e++){let a=n.noise(r*t,e*t);i.set(r,e,n.color(255*a,255*a,255*a,255))}i.updatePixels()})({scale:.005,width:a,height:o});new l(n,i,5,a,o).cells.forEach((e=>{let r={x:e.polygon.reduce(((e,n)=>e+n.x),0)/e.polygon.length,y:e.polygon.reduce(((e,n)=>e+n.y),0)/e.polygon.length};(e=>{const{width:r,height:a,x:o,y:i,scale:s}=e;return n.noise(o*s,i*s)>.4&&t({width:r,height:a,x:o,y:i})})({width:a,height:o,x:r.x,y:r.y,scale:.006})?n.fill(177,166,148):n.fill(54,54,94),n.beginShape(),e.polygon.forEach((e=>{n.vertex(e.x,e.y)})),n.endShape(n.CLOSE)}))},c=e=>{const{height:n,width:t,shape:r,noiseSeed:o}=e,i=(0,a.useCallback)(((e,r)=>{return(a={height:n,width:t},(e,n)=>{e.createCanvas(a.width,a.height).parent(n),e.noLoop()})(e,r);var a}),[n,t]),s=(0,a.useCallback)((e=>p({shape:r,width:t,height:n,noiseSeed:o})(e)),[n,o,r,t]);return a.createElement("div",null,a.createElement(h,{setup:i,draw:s}))},d=e=>{const{width:n,height:t,x:r,y:a}=e,o=.25*n,i=.75*n,s=.25*t,l=.75*t,h=.35*n;return Math.pow(r-(o+i)/2,2)+Math.pow(a-(s+l)/2,2)<Math.pow(h,2)},m=()=>a.createElement(i.Z,{fallback:a.createElement("div",null)},(()=>a.createElement(a.Suspense,{fallback:null},a.createElement(c,{width:500,height:500,noiseSeed:0,shape:d}))));var u=t(5e3);const g='import BrowserOnly from "@docusaurus/BrowserOnly";\nimport { PTG, sphereShape } from "@idealjs/ptg";\nimport React, { Suspense } from "react";\n\nconst PTGDemo = () => {\n  return (\n    <BrowserOnly fallback={<div />}>\n      {() => {\n        return (\n          <Suspense fallback={null}>\n            <PTG width={500} height={500} noiseSeed={0} shape={sphereShape} />\n          </Suspense>\n        );\n      }}\n    </BrowserOnly>\n  );\n};\n\nexport default PTGDemo;\n',w='import type P5 from "p5";\nimport { Vector } from "p5";\nimport React, { lazy, useCallback } from "react";\n\nimport { VoronoiDiagram } from "../utils/voronio";\n\nconst Sketch = lazy(() => import("react-p5"));\n\nconst createSetup =\n  (params: { height: number; width: number }) =>\n  (p5: P5, canvasParentRef: Element) => {\n    p5.createCanvas(params.width, params.height).parent(canvasParentRef);\n    p5.noLoop();\n  };\n\nconst createDraw =\n  (params: {\n    shape: (params: {\n      width: number;\n      height: number;\n      x: number;\n      y: number;\n    }) => boolean;\n    noiseSeed: number;\n    width: number;\n    height: number;\n  }) =>\n  (p5: P5) => {\n    const { shape, noiseSeed, width, height } = params;\n    const noiseShape = (params: {\n      height: number;\n      width: number;\n      x: number;\n      y: number;\n      scale: number;\n    }) => {\n      const { width, height, x, y, scale } = params;\n      // p5.noiseSeed(noiseSeed)\n      const value = p5.noise(x * scale, y * scale);\n      return value > 0.4 && shape({ width, height, x, y });\n    };\n\n    const createNoiseMap = (params: {\n      scale: number;\n      width: number;\n      height: number;\n    }) => {\n      const { scale, width, height } = params;\n      let img = p5.createImage(width, height);\n      p5.noiseSeed(noiseSeed);\n      img.loadPixels();\n      for (let x = 0; x < img.width; x++) {\n        for (let y = 0; y < img.height; y++) {\n          let value = p5.noise(x * scale, y * scale);\n          img.set(x, y, p5.color(value * 255, value * 255, value * 255, 255));\n        }\n      }\n      img.updatePixels();\n      return img;\n    };\n\n    const points: Vector[] = [];\n    for (let i = 0; i < 1000; i++) {\n      points.push(\n        p5.createVector(Math.random() * width, Math.random() * height)\n      );\n    }\n\n    const noiseMap = createNoiseMap({ scale: 0.005, width, height });\n\n    const voronoi = new VoronoiDiagram(p5, points, 5, width, height);\n    voronoi.cells.forEach((cell) => {\n      let centroid = {\n        x: cell.polygon.reduce((sum, v) => sum + v.x, 0) / cell.polygon.length,\n        y: cell.polygon.reduce((sum, v) => sum + v.y, 0) / cell.polygon.length,\n      };\n\n      // Decide whether or not to color the cell\n      if (\n        noiseShape({\n          width,\n          height,\n          x: centroid.x,\n          y: centroid.y,\n          scale: 0.006,\n        })\n      ) {\n        p5.fill(177, 166, 148); // Color the cell green\n      } else {\n        p5.fill(54, 54, 94); // Color the cell white\n      }\n      p5.beginShape();\n      cell.polygon.forEach((point) => {\n        p5.vertex(point.x, point.y);\n      });\n      p5.endShape(p5.CLOSE);\n    });\n    // p5.image(noiseMap,0,0)\n  };\n\ninterface IProps {\n  height: number;\n  width: number;\n  noiseSeed: number;\n  shape: (params: {\n    width: number;\n    height: number;\n    x: number;\n    y: number;\n  }) => boolean;\n}\n\nconst PTG = (props: IProps) => {\n  const { height, width, shape, noiseSeed } = props;\n  const setup = useCallback(\n    (p5: P5, canvasParentRef: Element) => {\n      return createSetup({ height, width })(p5, canvasParentRef);\n    },\n    [height, width]\n  );\n\n  const draw = useCallback(\n    (p5: P5) => {\n      return createDraw({\n        shape,\n        width,\n        height,\n        noiseSeed,\n      })(p5);\n    },\n    [height, noiseSeed, shape, width]\n  );\n\n  return (\n    <div>\n      <Sketch setup={setup} draw={draw} />\n    </div>\n  );\n};\n\nexport default PTG;\n',y={},f="PTG",b={unversionedId:"PTG",id:"PTG",title:"PTG",description:"PTG represents for Procedrual Terrain Generation",source:"@site/docs/PTG.mdx",sourceDirName:".",slug:"/PTG",permalink:"/jellyfish/docs/PTG",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/PTG.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Asset IO Engine",permalink:"/jellyfish/docs/Asset IO Engine"},next:{title:"Runtime Engine",permalink:"/jellyfish/docs/Runtime Engine"}},x={},P=[],v={toc:P},S="wrapper";function k(e){let{components:n,...t}=e;return(0,o.kt)(S,(0,r.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ptg"},"PTG"),(0,o.kt)("p",null,"PTG represents for Procedrual Terrain Generation\nIn this example, we use the voronio diagram to generate cells with borduaries, and assign different cell to either water or land biomes.\nTo make sure the shaped always surrounded by water, the boundary of the noise map will always be 0.\nWhy not use noise map to generate shape directly? Coz we can't get clear coastline by only filter the noise map, no matter what kind of the map it is.\nInstead generate terrain using noise map and erosion algo to match the natural process as much as possible, we first define the final shape of the terrain, this way, the final result would be easier to control and more interesting to play in the game, compared to the real natural way."),(0,o.kt)(m,{mdxType:"PTGDemo"}),(0,o.kt)(u.Z,{language:"tsx",mdxType:"CodeBlock"},g),(0,o.kt)(u.Z,{language:"tsx",mdxType:"CodeBlock"},w))}k.isMDXComponent=!0}}]);