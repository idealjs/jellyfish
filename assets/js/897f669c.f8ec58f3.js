"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[676],{876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,u=c["".concat(l,".").concat(m)]||c[m]||h[m]||i;return n?r.createElement(u,o(o({ref:t},p),{},{components:n})):r.createElement(u,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3285:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=n(7896),a=(n(2784),n(876));const i={},o="Rendering",s={unversionedId:"Rendering",id:"Rendering",title:"Rendering",description:"Key Concepts of Rendering:",source:"@site/docs/Rendering.md",sourceDirName:".",slug:"/Rendering",permalink:"/jellyfish/docs/Rendering",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/Rendering.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Physics",permalink:"/jellyfish/docs/Physics"},next:{title:"Runtime",permalink:"/jellyfish/docs/Runtime"}},l={},d=[{value:"<strong>Key Concepts of Rendering:</strong>",id:"key-concepts-of-rendering",level:3},{value:"<strong>Circumstances Permitting RenderPipeline Reuse:</strong>",id:"circumstances-permitting-renderpipeline-reuse",level:3},{value:"<strong>Steps to Render a Pass:</strong>",id:"steps-to-render-a-pass",level:3},{value:"<strong>When to Utilize Instancing:</strong>",id:"when-to-utilize-instancing",level:3},{value:"<strong>Frame Rendering Optimization:</strong>",id:"frame-rendering-optimization",level:3},{value:"<strong>Renderer Function Plan:</strong>",id:"renderer-function-plan",level:3},{value:"<strong>Rendering a Frame Process:</strong>",id:"rendering-a-frame-process",level:3},{value:"<strong>Note:</strong>",id:"note",level:3}],p={toc:d},c="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"rendering"},"Rendering"),(0,a.kt)("h3",{id:"key-concepts-of-rendering"},(0,a.kt)("strong",{parentName:"h3"},"Key Concepts of Rendering:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Vertex Buffer and Index Buffer: These are specialized buffers used specifically for inputting vertex data."),(0,a.kt)("li",{parentName:"ul"},"Bind Group: This is utilized to supply additional data to the rendering pipeline. It inputs data into the shader, apart from vertex data. This could include textures, samplers, transformation matrices, and other custom variables, among others.")),(0,a.kt)("h3",{id:"circumstances-permitting-renderpipeline-reuse"},(0,a.kt)("strong",{parentName:"h3"},"Circumstances Permitting RenderPipeline Reuse:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Shaders"),": The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," can be reused if the vertex, fragment, and other shaders utilized within the pipeline are identical."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Input State"),": The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," can be reused if the layout of the vertex buffers remains consistent. This includes the number of buffers, as well as the format and stride of each buffer (Multiple attributes can exist in one buffer or span across multiple buffers). This can be normalized during asset importing."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Primitive Topology"),": If the topology of the vertices remains the same (i.e., they form points, lines, or triangles), the ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," can be reused."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Depth-Stencil and Blend State"),": The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," can be reused if the settings for depth and stencil testing, as well as blending functions, remain the same."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Output Formats"),": The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline")),' can be reused if the formats of the color and depth-stencil attachments (also known as "render targets") remain the same.'),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Rasterization State"),": The rasterization state encompasses parameters such as the cull mode (which determines whether back-facing or front-facing polygons are discarded), the front-face orientation (which establishes whether polygons are considered front-facing based on clockwise or counterclockwise vertex order), and the depth bias parameters (which help prevent z-fighting). The ",(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," can be reused if these parameters remain consistent.")),(0,a.kt)("p",null,"Please note that reusing the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"RenderPipeline"))," does not imply that every object drawn with that pipeline will have the same appearance. The appearance of objects can still be varied by using different bind groups to supply different resources (like textures and uniform values) to the shaders, and by drawing different vertex data. Moreover, the pipeline only defines the settings for depth and stencil testing, and blending; the actual depth, stencil, and color values come from the textures attached as render targets."),(0,a.kt)("h3",{id:"steps-to-render-a-pass"},(0,a.kt)("strong",{parentName:"h3"},"Steps to Render a Pass:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"setPipeline")),": This sets the active render pipeline."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"setVertexBuffer")),": This sets the active vertex buffer."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"setIndexBuffer")),": This sets the active index buffer."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBindGroup")),": This function must be called to input all variables into the shader."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"render")),": This initiates the rendering process.")),(0,a.kt)("p",null,"Rendering a single frame may involve multiple passes, each responsible for different tasks. Some passes are assigned to render different pipelines (for example, solid models first, then semi-transparent models), while others are dedicated to post-processing tasks."),(0,a.kt)("h3",{id:"when-to-utilize-instancing"},(0,a.kt)("strong",{parentName:"h3"},"When to Utilize Instancing:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Geometry"),": All instances must share the same geometry, meaning they use identical vertex and index data. This is a fundamental requirement of instanced rendering as it enables the GPU to reuse the same data for each instance."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Same Render State"),": All instances are drawn with the same render pipeline, which includes the shaders, vertex layout, and various render states like blending and depth testing. Although all instances should have the same overall render state, their appearances can vary as per-instance data can be used to modify properties like color, texture, or parts of the vertex data for each instance."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Different Transformations or Other Per-Instance Data"),": While all instances share the same geometry and render state, they typically have different transformations (position, rotation, scale), allowing them to appear at different locations and orientations. This per-instance data, such as transformations or other properties like color or texture coordinates, can be passed to the shaders in several ways, like through a vertex buffer with instanced data, or through a uniform buffer or texture accessed using the instance ID.")),(0,a.kt)("p",null,"If these conditions are met, you can use the ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"drawInstanced"))," or ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"drawIndexedInstanced"))," methods in WebGPU to draw multiple instances with a single draw call. Each instance will be drawn using the same vertex and index data, but the shaders can access per-instance data to customize the appearance and transformation of each instance."),(0,a.kt)("p",null,"Because ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"drawInstanced"))," is a single function call, all the shader input information required for different instances needs to be passed in at once using ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBindGroup")),". For instance, if there are 100 blocks each with its own transformation matrix, and you want to use ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"drawInstanced")),", then the corresponding 100 transformation matrices need to be stored in a single ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"bindGroup")),". Even if only one block's transformation matrix changes, the entire ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"bindGroup"))," needs to be updated."),(0,a.kt)("h3",{id:"frame-rendering-optimization"},(0,a.kt)("strong",{parentName:"h3"},"Frame Rendering Optimization:")),(0,a.kt)("p",null,"The most time-consuming operation in each pass is ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setPipeline")),". Hence, the primary goal when rendering a frame is to minimize the number of ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setPipeline"))," calls. Subsequently, the number of remaining operation calls should also be reduced to the lowest possible."),(0,a.kt)("p",null,"We have already discussed in which cases a pipeline can be reused. The most important point is that the reusability of a pipeline is not associated with specific vertexBuffer, indexBuffer, or bindGroup. This means that even if there are 100 models of different shapes, as long as their pipeline settings are identical, only one ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setPipeline"))," call is needed."),(0,a.kt)("p",null,"Next, let's consider the order of calling vertex, index, and bindGroup. If the number of different data sets in the vertex data buffer is less than the number of different data sets in the shader variable buffer, the vertex buffer setting should be called first, and vice versa. For example, if there are three models with the same shape, but each model has different shader variables, then calling ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBuffer"))," once followed by ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBindGroup"))," three times will result in four calls in total. On the other hand, if you first call ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBindGroup"))," three times, each time will require a separate ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBuffer"))," call, resulting in six calls in total."),(0,a.kt)("h3",{id:"renderer-function-plan"},(0,a.kt)("strong",{parentName:"h3"},"Renderer Function Plan:")),(0,a.kt)("p",null,"Each function will reset the pipeline, buffer, and bindgroup cache data, providing the most direct optimization data for the final render function, including the indicator of whether to ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBuffer"))," first or ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"setBindGroup"))," first."),(0,a.kt)("p",null,"We will incorporate a function to transform the game state data retrieved from the ECS system into a format suitable render state for our rendering engine."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"/*\naddPrimitive procedure:\n1. Update vertexBuffer cache: Check the accessor reference address of the primitive, add to the vertexBuffer cache or bind the primitive's reference.\n2. Update indexBuffer cache: Check the indices reference address of the primitive, add to the indexBuffer cache or bind the primitive's reference.\n3. Update pipeline cache: Check the pipeline parameters required by the primitive, add to the pipeline cache or bind the primitive's reference.\n4. Update bindGroup and bindGroupLayout cache: Use the SpirV Cross library to perform reflection on the shader code of the primitive, get input and output information, and create bindGroup and bindGroupLayout for each input. \n   Note: \n   It's important to determine whether the primitive needs instance rendering. The method to determine the rendering has been mentioned above. \n   If instance rendering is needed, then check whether there is a batch of bindGroup data in the cache for instance rendering. If not, create a new one. \n   If yes, expand it, and all bindGroups related to the instance rendering of the primitive should be deleted.\n*/\n\nfunction addPrimitive(primitive) {\n    // Placeholder for your implementation\n    // 1. Update vertexBuffer cache\n    // ...\n\n    // 2. Update indexBuffer cache\n    // ...\n\n    // 3. Update pipeline cache\n    // ...\n\n    // 4. Update bindGroup and bindGroupLayout cache\n    // ...\n}\n\n/*\nconvertGameStateToRenderState procedure:\n1. Get the game state, which contains information about all the entities and their current states.\n2. Iterate over the entities and transform their game state into a format that can be used for rendering.\n3. Update the render state based on the transformed data.\n4. This converted render state can then be used in the rendering pipeline.\n*/\n\nfunction convertGameStateToRenderState(gameState) {\n    // Placeholder for your implementation\n    // 1. Get game state\n    // ...\n\n    // 2. Iterate over entities and transform game state to render state\n    // ...\n\n    // 3. Update the render state based on transformed data\n    // ...\n\n    // Return the updated render state\n    // return renderState;\n}\n")),(0,a.kt)("h3",{id:"rendering-a-frame-process"},(0,a.kt)("strong",{parentName:"h3"},"Rendering a Frame Process:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Retrieve all pipeline data."),(0,a.kt)("li",{parentName:"ol"},"For each pipeline, enter the loop:",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Determine which collection, buffer or bindGroup, under this pipeline has more quantity, then set that one first.")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"rendererState": {\n  "pipeline": [\n    {\n      "pipelineID": "UniqueIDForThePipeline",\n      "shaders": {\n        "vertexShader": "VertexShaderCode",\n        "fragmentShader": "FragmentShaderCode",\n        // more shaders if applicable\n      },\n      "bindGroup": [\n        {\n          "bindGroupID": "UniqueIDForTheBindGroup",\n          "resources": [\n            {\n              "resourceID": "UniqueIDForResource",\n              "resourceType": "Texture|Buffer|Sampler",\n              "resourceDetails": { /* specific details depending on the resource type */ }\n            },\n            // more resources\n          ]\n        },\n        // more bind groups\n      ],\n      "vertexBuffer": [\n        {\n          "bufferID": "UniqueIDForTheVertexBuffer",\n          "bufferLayout": { /* details about the buffer layout */ },\n          "bufferData": { /* actual vertex data */ }\n        },\n        // more vertex buffers\n      ],\n      "indexBuffer": [\n        {\n          "bufferID": "UniqueIDForTheIndexBuffer",\n          "bufferData": { /* actual index data */ }\n        }\n        // more index buffers\n      ]\n    }\n    // more pipelines\n  ]\n}\n')),(0,a.kt)("h3",{id:"note"},(0,a.kt)("strong",{parentName:"h3"},"Note:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The original game state is stored in runtime engine state manager,"),(0,a.kt)("li",{parentName:"ol"},"After model import, the vertex attribute buffer data should not be merged. The reason being, if some shaders do not use certain attributes, graphics memory will be wasted. During rendering, we only load buffers of the vertex attributes used by the shader.")))}h.isMDXComponent=!0}}]);