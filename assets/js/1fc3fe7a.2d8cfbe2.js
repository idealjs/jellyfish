"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[773],{876:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>u});var s=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),c=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=c(e.components);return s.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,u=p["".concat(l,".").concat(d)]||p[d]||m[d]||a;return n?s.createElement(u,o(o({ref:t},h),{},{components:n})):s.createElement(u,o({ref:t},h))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[p]="string"==typeof e?e:i,o[1]=r;for(var c=2;c<a;c++)o[c]=n[c];return s.createElement.apply(null,o)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},828:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=n(7896),i=(n(2784),n(876));const a={},o="Physics",r={unversionedId:"Physics",id:"Physics",title:"Physics",description:"Overview",source:"@site/docs/Physics.md",sourceDirName:".",slug:"/Physics",permalink:"/jellyfish/docs/Physics",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/Physics.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Packaging",permalink:"/jellyfish/docs/Packaging"},next:{title:"Rendering",permalink:"/jellyfish/docs/Rendering"}},l={},c=[{value:"<strong>Overview</strong>",id:"overview",level:3},{value:"<strong>Key Features</strong>",id:"key-features",level:3},{value:"<strong>Basic Usage</strong>",id:"basic-usage",level:3},{value:"<strong>About GPU physics:</strong>",id:"about-gpu-physics",level:3}],h={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,s.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"physics"},"Physics"),(0,i.kt)("h3",{id:"overview"},(0,i.kt)("strong",{parentName:"h3"},"Overview")),(0,i.kt)("p",null,"A physics engine is an essential component of a modern game engine, allowing for the simulation of physical systems in the game world. It calculates the changes in an object's position, rotation, and other physical attributes over time based on applied forces, friction, and other physical phenomena."),(0,i.kt)("h3",{id:"key-features"},(0,i.kt)("strong",{parentName:"h3"},"Key Features")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Collision Detection"),": Collision detection is the process of detecting when two or more objects have come into contact. The physics engine uses various algorithms to efficiently detect collisions in large game worlds filled with numerous entities."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Rigid Body Dynamics"),": This simulates the motion and rotation of solid objects (as opposed to fluid or soft, deformable bodies). The physics engine will apply Newton's laws of motion to calculate the new position and rotation of these objects."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Soft Body Dynamics"),": Unlike rigid body dynamics, soft body dynamics caters to objects that can deform and change shape. This could apply to numerous things like cloth, jelly, or even soft body characters."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Vehicle Physics"),": Many games involve the simulation of vehicles. The physics engine may include special features to simulate the complex interactions between the vehicle's wheels and the ground, as well as aerodynamics and engine mechanics."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Ragdoll Physics"),": This simulates the movement of a character's body upon death, taking into account gravity and joint constraints.")),(0,i.kt)("h3",{id:"basic-usage"},(0,i.kt)("strong",{parentName:"h3"},"Basic Usage")),(0,i.kt)("p",null,"The physics engine generally operates by first taking the objects in the runtime state ECS system and their initial states (positions, rotations, velocities, etc.) as input. Next, it calculates the forces acting on each object, such as gravity, friction, or custom forces defined by game logic. The engine then uses these forces to compute how each object's state should change over time."),(0,i.kt)("p",null,"The updated states are passed back to the ECS system, which uses them to render the objects at their new positions and rotations. This process is repeated many times per second to create the illusion of continuous movement."),(0,i.kt)("h3",{id:"about-gpu-physics"},(0,i.kt)("strong",{parentName:"h3"},"About GPU physics:")),(0,i.kt)("p",null,"A GPU-accelerated physics engine utilizes the immense parallel processing power of modern GPUs to perform physics calculations. This can result in a significant performance boost, particularly for games with complex physics simulations involving large numbers of objects."),(0,i.kt)("p",null,"The data flow from a GPU-accelerated physics engine to the game engine involves a few steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Simulation Setup"),": The physics engine first sets up the physical world on the CPU side. This involves defining the physical properties of the objects (like mass, shape, and initial velocity) and the forces at play (like gravity and wind). The data is then passed to the GPU."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Running the Simulation"),": The physics calculations are performed on the GPU. The GPU can handle many calculations simultaneously, making it perfect for physics simulations where the forces on many objects need to be calculated independently."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Reading the Results"),": Once the GPU has calculated the new states of the objects, this data is read back into system memory. This is often a bottleneck in the process due to the relatively slow speed of transferring data from the GPU to the CPU."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Update Game State"),": The game engine takes the updated physics data and applies it to the game objects, updating their positions, rotations, and other properties in the game world.")),(0,i.kt)("p",null,"In some architectures, steps 3 and 4 could be combined by using shared memory between the CPU and GPU or other advanced techniques to minimize data transfer."),(0,i.kt)("p",null,"Remember, using a GPU for physics calculations only makes sense if the physics calculations are complex and numerous enough to outweigh the overhead of transferring data between CPU and GPU. If the physics simulation is simple or if there are few objects, it might be faster to perform the calculations directly on the CPU."),(0,i.kt)("p",null,"Overall, GPU-based physics can lead to more realistic and immersive games by allowing for more detailed physics simulations. However, it also introduces additional complexity into the game development process and requires careful management of the data flow between the CPU and GPU."))}m.isMDXComponent=!0}}]);