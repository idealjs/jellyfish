"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[452],{8229:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>b,default:()=>P,frontMatter:()=>f,metadata:()=>w,toc:()=>v});var o=t(7896),r=t(2784),l=t(876),s=t(9979),i=t(1908);class a{cells=[];constructor(e,n,t,o,r){void 0===t&&(t=1);for(let l=0;l<t;l++){const s=i.Z.from(n.map((e=>[e.x,e.y]))),a=s.voronoi([0,0,o,r]);this.cells=n.map(((n,t)=>{const o=a.cellPolygon(t);return{site:n,polygon:o?o.map((n=>{let[t,o]=n;return e.createVector(t,o)})):[],neighbors:Array.from(s.neighbors(t))}})),l<t-1&&(n=this.cells.map((n=>this.centroid(e,n.polygon))))}}centroid(e,n){let t=0,o=0;for(let r of n)t+=r.x,o+=r.y;return e.createVector(t/n.length,o/n.length)}}const h=(0,r.lazy)((()=>t.e(291).then(t.t.bind(t,2291,23)))),c=e=>n=>{const{shape:t,noiseSeed:o,width:r,height:l}=e,s=(e,n,t)=>{const o=n.polygon.map((e=>`${e.x},${e.y}`)),r=t.polygon.map((e=>`${e.x},${e.y}`)),l=o.filter((e=>r.includes(e)));return l.length>0?l.map((n=>{const[t,o]=n.split(",").map(Number);return e.createVector(t,o)})):null},i=[];for(let e=0;e<10;e++)i.push(n.createVector(Math.random()*r,Math.random()*l));const h=new a(n,i,5,r,l);h.cells.forEach((e=>{let o={x:e.polygon.reduce(((e,n)=>e+n.x),0)/e.polygon.length,y:e.polygon.reduce(((e,n)=>e+n.y),0)/e.polygon.length};(e=>{const{width:o,height:r,x:l,y:s,scale:i}=e;return n.noise(l*i,s*i)>.4&&t({width:o,height:r,x:l,y:s})})({width:r,height:l,x:o.x,y:o.y,scale:.006})?n.fill(177,166,148):n.fill(54,54,94),n.beginShape(),e.polygon.forEach((e=>{n.vertex(e.x,e.y)})),n.endShape(n.CLOSE)})),n.fill(255,0,0);for(const e of h.cells)n.ellipse(e.site.x,e.site.y,10,10);n.stroke(255,0,0);for(const e of h.cells)if(e.neighbors)for(const t of e.neighbors){const o=h.cells[t];n.line(e.site.x,e.site.y,o.site.x,o.site.y)}for(let e=0;e<h.cells.length;e++){let t=h.cells[e];if(t.neighbors)for(let e=0;e<t.neighbors.length;e++){let o=h.cells[t.neighbors[e]];const r=s(n,t,o);r&&(n.stroke(0,0,255),n.line(r[0].x,r[0].y,r[1].x,r[1].y))}}},p=e=>{const{height:n,width:t,shape:o,noiseSeed:l}=e,s=(0,r.useCallback)(((e,o)=>{return(r={height:n,width:t},(e,n)=>{e.createCanvas(r.width,r.height).parent(n),e.noLoop()})(e,o);var r}),[n,t]),i=(0,r.useCallback)((e=>c({shape:o,width:t,height:n,noiseSeed:l})(e)),[n,l,o,t]);return r.createElement("div",null,r.createElement(h,{setup:s,draw:i}))},d=e=>{const{width:n,height:t,x:o,y:r}=e,l=.25*n,s=.75*n,i=.25*t,a=.75*t,h=.35*n;return Math.pow(o-(l+s)/2,2)+Math.pow(r-(i+a)/2,2)<Math.pow(h,2)},g=()=>r.createElement(s.Z,{fallback:r.createElement("div",null)},(()=>r.createElement(r.Suspense,{fallback:null},r.createElement(p,{width:500,height:500,noiseSeed:0,shape:d}))));var u=t(5e3);const m='import BrowserOnly from "@docusaurus/BrowserOnly";\nimport { PTG, sphereShape } from "@idealjs/ptg";\nimport React, { Suspense } from "react";\n\nconst PTGDemo = () => {\n  return (\n    <BrowserOnly fallback={<div />}>\n      {() => {\n        return (\n          <Suspense fallback={null}>\n            <PTG width={500} height={500} noiseSeed={0} shape={sphereShape} />\n          </Suspense>\n        );\n      }}\n    </BrowserOnly>\n  );\n};\n\nexport default PTGDemo;\n',y='import type P5 from "p5";\nimport { Vector } from "p5";\nimport React, { lazy, useCallback } from "react";\n\nimport { VoronoiCell, VoronoiDiagram } from "../utils/voronio";\n\nconst Sketch = lazy(() => import("react-p5"));\n\nconst createSetup =\n  (params: { height: number; width: number }) =>\n  (p5: P5, canvasParentRef: Element) => {\n    p5.createCanvas(params.width, params.height).parent(canvasParentRef);\n    p5.noLoop();\n  };\n\nconst createDraw =\n  (params: {\n    shape: (params: {\n      width: number;\n      height: number;\n      x: number;\n      y: number;\n    }) => boolean;\n    noiseSeed: number;\n    width: number;\n    height: number;\n  }) =>\n  (p5: P5) => {\n    const { shape, noiseSeed, width, height } = params;\n    const noiseShape = (params: {\n      height: number;\n      width: number;\n      x: number;\n      y: number;\n      scale: number;\n    }) => {\n      const { width, height, x, y, scale } = params;\n      // p5.noiseSeed(noiseSeed)\n      const value = p5.noise(x * scale, y * scale);\n      return value > 0.4 && shape({ width, height, x, y });\n    };\n\n    const createNoiseMap = (params: {\n      scale: number;\n      width: number;\n      height: number;\n    }) => {\n      const { scale, width, height } = params;\n      let img = p5.createImage(width, height);\n      p5.noiseSeed(noiseSeed);\n      img.loadPixels();\n      for (let x = 0; x < img.width; x++) {\n        for (let y = 0; y < img.height; y++) {\n          let value = p5.noise(x * scale, y * scale);\n          img.set(x, y, p5.color(value * 255, value * 255, value * 255, 255));\n        }\n      }\n      img.updatePixels();\n      return img;\n    };\n\n    const getSharedEdge = (\n      p5: any,\n      cell1: VoronoiCell,\n      cell2: VoronoiCell\n    ): Vector[] | null => {\n      // Convert polygon vertices to string representation for comparison\n      const cell1Edges = cell1.polygon.map((v) => `${v.x},${v.y}`);\n      const cell2Edges = cell2.polygon.map((v) => `${v.x},${v.y}`);\n\n      // Find common edges\n      const sharedEdges = cell1Edges.filter((edge) =>\n        cell2Edges.includes(edge)\n      );\n\n      // If there are exactly two shared edges, return them as Vectors\n      if (sharedEdges.length > 0) {\n        return sharedEdges.map((edge) => {\n          const [x, y] = edge.split(",").map(Number);\n          return p5.createVector(x, y);\n        });\n      }\n\n      // If there are not exactly two shared edges, return null\n      return null;\n    };\n\n    const points: Vector[] = [];\n    for (let i = 0; i < 10; i++) {\n      points.push(\n        p5.createVector(Math.random() * width, Math.random() * height)\n      );\n    }\n\n    const voronoi = new VoronoiDiagram(p5, points, 5, width, height);\n    voronoi.cells.forEach((cell) => {\n      let centroid = {\n        x: cell.polygon.reduce((sum, v) => sum + v.x, 0) / cell.polygon.length,\n        y: cell.polygon.reduce((sum, v) => sum + v.y, 0) / cell.polygon.length,\n      };\n\n      // Decide whether or not to color the cell\n      if (\n        noiseShape({\n          width,\n          height,\n          x: centroid.x,\n          y: centroid.y,\n          scale: 0.006,\n        })\n      ) {\n        p5.fill(177, 166, 148); // Color the cell green\n      } else {\n        p5.fill(54, 54, 94); // Color the cell white\n      }\n      p5.beginShape();\n      cell.polygon.forEach((point) => {\n        p5.vertex(point.x, point.y);\n      });\n      p5.endShape(p5.CLOSE);\n    });\n\n    p5.fill(255, 0, 0); // Set the color of the circles (R,G,B)\n    for (const cell of voronoi.cells) {\n      p5.ellipse(cell.site.x, cell.site.y, 10, 10); // Draw a circle at the site position\n    }\n\n    // draw connections\n    p5.stroke(255, 0, 0); // Set the color of the lines (R,G,B)\n    for (const cell of voronoi.cells) {\n      if (cell.neighbors) {\n        for (const neighborIndex of cell.neighbors) {\n          const neighbor = voronoi.cells[neighborIndex];\n          p5.line(cell.site.x, cell.site.y, neighbor.site.x, neighbor.site.y);\n        }\n      }\n    }\n\n    for (let i = 0; i < voronoi.cells.length; i++) {\n      let cell = voronoi.cells[i];\n      if (cell.neighbors) {\n        for (let j = 0; j < cell.neighbors.length; j++) {\n          let neighborCell = voronoi.cells[cell.neighbors[j]];\n          const sharedEdge = getSharedEdge(p5,cell, neighborCell);\n          if (sharedEdge) {\n            p5.stroke(0, 0, 255); // Set stroke color to red for shared edges\n            p5.line(\n              sharedEdge[0].x,\n              sharedEdge[0].y,\n              sharedEdge[1].x,\n              sharedEdge[1].y\n            );\n          }\n        }\n      }\n    }\n  };\n\ninterface IProps {\n  height: number;\n  width: number;\n  noiseSeed: number;\n  shape: (params: {\n    width: number;\n    height: number;\n    x: number;\n    y: number;\n  }) => boolean;\n}\n\nconst PTG = (props: IProps) => {\n  const { height, width, shape, noiseSeed } = props;\n  const setup = useCallback(\n    (p5: P5, canvasParentRef: Element) => {\n      return createSetup({ height, width })(p5, canvasParentRef);\n    },\n    [height, width]\n  );\n\n  const draw = useCallback(\n    (p5: P5) => {\n      return createDraw({\n        shape,\n        width,\n        height,\n        noiseSeed,\n      })(p5);\n    },\n    [height, noiseSeed, shape, width]\n  );\n\n  return (\n    <div>\n      <Sketch setup={setup} draw={draw} />\n    </div>\n  );\n};\n\nexport default PTG;\n',f={},b="PTG",w={unversionedId:"PTG",id:"PTG",title:"PTG",description:"PTG represents for Procedrual Terrain Generation",source:"@site/docs/PTG.mdx",sourceDirName:".",slug:"/PTG",permalink:"/jellyfish/docs/PTG",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/PTG.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Audio",permalink:"/jellyfish/docs/Audio"},next:{title:"Packaging",permalink:"/jellyfish/docs/Packaging"}},x={},v=[],S={toc:v},k="wrapper";function P(e){let{components:n,...t}=e;return(0,l.kt)(k,(0,o.Z)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"ptg"},"PTG"),(0,l.kt)("p",null,"PTG represents for Procedrual Terrain Generation\nIn this example, we use the voronio diagram to generate cells with borduaries, and assign different cell to either water or land biomes.\nTo make sure the shaped always surrounded by water, the boundary of the noise map will always be 0.\nWhy not use noise map to generate shape directly? Coz we can't get clear coastline by only filter the noise map, no matter what kind of the map it is.\nInstead generate terrain using noise map and erosion algo to match the natural process as much as possible, we first define the final shape of the terrain, this way, the final result would be easier to control and more interesting to play in the game, compared to the real natural way."),(0,l.kt)(g,{mdxType:"PTGDemo"}),(0,l.kt)(u.Z,{language:"tsx",mdxType:"CodeBlock"},m),(0,l.kt)(u.Z,{language:"tsx",mdxType:"CodeBlock"},y))}P.isMDXComponent=!0}}]);