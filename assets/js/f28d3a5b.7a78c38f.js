"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5],{876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,u=p["".concat(c,".").concat(d)]||p[d]||h[d]||s;return n?o.createElement(u,r(r({ref:t},m),{},{components:n})):o.createElement(u,r({ref:t},m))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:a,r[1]=i;for(var l=2;l<s;l++)r[l]=n[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(7896),a=(n(2784),n(876));const s={},r="Runtime",i={unversionedId:"Runtime",id:"Runtime",title:"Runtime",description:"The Runtime Engine is responsible for managing the game state and scene resources. It is important to understand that both the editor and the in-game environment operate within the runtime.",source:"@site/docs/Runtime.md",sourceDirName:".",slug:"/Runtime",permalink:"/jellyfish/docs/Runtime",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/Runtime.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Rendering",permalink:"/jellyfish/docs/Rendering"},next:{title:"Hello",permalink:"/jellyfish/docs/intro"}},c={},l=[{value:"<strong>About ECS system</strong>:",id:"about-ecs-system",level:3},{value:"<strong>About state manager</strong>:",id:"about-state-manager",level:3},{value:"<strong>Note:</strong>",id:"note",level:3}],m={toc:l},p="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"runtime"},"Runtime"),(0,a.kt)("p",null,"The Runtime Engine is responsible for managing the game state and scene resources. It is important to understand that both the editor and the in-game environment operate within the runtime."),(0,a.kt)("p",null,"Typically, the Runtime Engine initiates as soon as we start the editor and continues to operate until the editor is closed. When we initiate the in-game runtime, we are essentially launching a separate Runtime Engine parallel to the editor's Runtime Engine. Each of these engines manages unique runtime states."),(0,a.kt)("p",null,"Upon initializing a runtime instance, the Entity-Component-System (ECS) automatically starts up to manage the state."),(0,a.kt)("h3",{id:"about-ecs-system"},(0,a.kt)("strong",{parentName:"h3"},"About ECS system"),":"),(0,a.kt)("p",null,"The Entity Component System (ECS) is a programming paradigm that follows a data-oriented design, contrasting with the traditionally dominant Object-Oriented Programming (OOP) approach used in game engine development. Historically, OOP has been prevalent, but it can result in data being dispersed throughout memory, which presents challenges for the CPU in retrieving data efficiently. ECS addresses this issue by organizing data in a manner that is more compact and contiguous in underlying memory, thereby enhancing CPU cache coherency and data access efficiency."),(0,a.kt)("p",null,"Imagine creating a game scene after successfully importing a glTF asset. The first step involves loading the asset into the scene. However, it is not feasible to directly load a glTF file into the runtime using a third-party glTF loader. One reason for this is the potential reusability of some assets within the glTF, such as textures and meshes. We would want to duplicate these assets in our runtime scene to increase complexity. For instance, if we have a glTF file for a rock and wish to place 100 identical rocks into the scene, loading this glTF using a third-party loader would require calling the load function 100 times. Moreover, it would prevent us from reusing textures from this glTF for other meshes from another glTF."),(0,a.kt)("p",null,"Our engine implements a solution to this problem using a runtime loading program referred to as a .meta file loader. The .meta file of a glTF can represent the scene structure of that glTF, as well as references to its metadata. Once a glTF asset passes through the Asset IO Engine pipeline, it is parsed into several other pieces of metadata, such as texture.meta."),(0,a.kt)("p",null,"Loading a prefab first involves reading the prefab's .meta file. This action extracts the basic hierarchical structure of the prefab, and creates GameObject nodes based on this structure. It then reads the corresponding components connected to each of these nodes and registers them into the ECS. This procedure also feeds the component data into the ECS. For instance, after recreating the node graph from the prefab meta, the next step is to register the mesh component into the ECS. We load the mesh binary data from the disk, based on the reference file path in the meta file, and link the mesh component to its corresponding entity. Subsequently, when the render or physics engine requests scene data, the state management program only sends one copy of the mesh along with the necessary information."),(0,a.kt)("p",null,"The ECS is simply a program that manipulates the scene graph based on incoming request API calls. The actual scene graph data is stored in a specific location within the runtime instance as a pool that only the ECS system can access."),(0,a.kt)("p",null,"The ECS also manages the process of calling other sub-engine\u2019s APIs to export the latest scene graph. For instance, the render engine has an API that can convert the scene graph into render states, based on different low-level render APIs, and store it into the render engine's data pool. Each time rendering occurs, the render engine first examines its own pool and renders the picture based on the provided information. The information that the render engine uses will be updated once the ECS's write function is activated. If we need to load a new mesh component within the scene graph state pool, this action can only be achieved by calling the ECS to load the mesh. By loading the mesh, the ECS writes different data into the pool, thereby triggering an update of the data in the render engine's pool."),(0,a.kt)("p",null,"To ensure that each sub-engine operates efficiently, any data structure related to a specific sub-engine that is stored in the pool is well-structured. This arrangement helps to avoid unnecessary data conversions during runtime."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"interface GameObject {\n    id: number;\n    components: Component[];\n    // ...other properties\n}\n\ninterface Component {\n    // ...component properties\n}\n\ninterface Mesh extends Component {\n    // ...mesh specific properties\n}\n\ninterface Texture extends Component {\n    // ...texture specific properties\n}\n\ninterface Transform extends Component {\n    // ...transform specific properties\n}\n\ninterface Collider extends Component {\n    // ...collider specific properties\n}\n\n")),(0,a.kt)("p",null,"For any registered sub system to work synchronously, any sub system must provide an API called update for ECS to inform that sub system for any data change events. Here is the ECS system structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"class ECS {\n    entities: GameObject[] = [];\n    meshes: Map<number, Mesh> = new Map();\n    textures: Map<number, Texture> = new Map();\n    //...more component pools\n\n    registerSystem(system) {\n        this.systems.push(system);\n    }\n\n    unregisterSystem(system) {\n        const index = this.systems.indexOf(system);\n        if (index > -1) {\n            this.systems.splice(index, 1);\n        }\n    }\n\n    updateSystems(entities) {\n        for (let system of this.systems) {\n            system.update(entities);\n        }\n    }\n\n    createGameObject(components: Component[]): GameObject {\n        const id = this.generateUniqueId();\n        const gameObject = { id, components };\n        this.gameObjectPool.push(gameObject);\n\n        for (const component of components) {\n            if (component instanceof MeshComponent) {\n                this.meshComponentPool.set(id, component);\n            } else if (component instanceof TextureComponent) {\n                this.textureComponentPool.set(id, component);\n            }\n            // ... repeat for other component types ...\n        }\n\n        this.updateSystemPools(gameObject);\n\n        return gameObject;\n    }\n\n    deleteGameObject(id: number) {\n        this.gameObjectPool = this.gameObjectPool.filter(obj => obj.id !== id);\n        this.meshComponentPool.delete(id);\n        this.textureComponentPool.delete(id);\n        // ... repeat for other component types ...\n\n        this.updateSystemPools();\n    }\n\n    addComponent(gameObjectId: number, component: Component) {\n        if (component instanceof MeshComponent) {\n            this.meshComponentPool.set(gameObjectId, component);\n        } else if (component instanceof TextureComponent) {\n            this.textureComponentPool.set(gameObjectId, component);\n        }\n        // ... repeat for other component types ...\n\n        this.updateSystemPools();\n    }\n\n    removeComponent(gameObjectId: number, componentType: Function) {\n        if (componentType === MeshComponent) {\n            this.meshComponentPool.delete(gameObjectId);\n        } else if (componentType === TextureComponent) {\n            this.textureComponentPool.delete(gameObjectId);\n        }\n        // ... repeat for other component types ...\n\n        this.updateSystemPools();\n    }\n\n    private updateSystemPools(changedGameObject?: GameObject) {\n        // Update the system pools based on the current state of the game objects and their components.\n        // This would depend on the specific needs of your systems.\n        // For example, you might need to rebuild the entire system pool, or you might be able to update\n        // it incrementally based on the game object that was added, updated, or deleted.\n    }\n\n    private generateUniqueId(): number {\n        // Generate a unique ID for a new game object.\n        // This could be as simple as incrementing a counter, or more complex if needed.\n    }\n\n        loadScene(){}\n\n        loadPrefab(){}\n\n}\n")),(0,a.kt)("p",null,"The Entity Component System (ECS) remains operational even in the absence of any active scenes in the runtime instance. The scene graph is merely another abstraction layered above the ECS, permitting the storage of multiple scene graph data while maintaining a singular location for runtime graph data. Notably, during runtime, only one scene can be active at any given time."),(0,a.kt)("h3",{id:"about-state-manager"},(0,a.kt)("strong",{parentName:"h3"},"About state manager"),":"),(0,a.kt)("p",null,"An effective strategy for realizing game state behavior is to adopt certain interfaces provided by the state manager, such as lifecycle updates. These interfaces can then be implemented within our specific component system management logic, which awaits calls from the state manager."),(0,a.kt)("p",null,"As for interactions with other sub-engines, like the physics engine, state system operates reciprocally. For instance, whenever a physics event takes place, the manager\u2019s ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"onCollide"))," API is activated, thus notifying all ECS component system management sections of this event, irrespective of whether the corresponding component entity is directly involved in the collision event."),(0,a.kt)("p",null,"In this way, the state manager can engage with other sub-engines, and they can interact with the state manager likewise."),(0,a.kt)("h3",{id:"note"},(0,a.kt)("strong",{parentName:"h3"},"Note:")),(0,a.kt)("p",null,"It's crucial to understand that the Entity Component System (ECS) and the State Manager are not standalone elements; instead, they collaborate to form the Runtime Manager. The ECS is responsible for managing game logic, while the State Manager oversees the overall game state and handles fundamental game events."))}h.isMDXComponent=!0}}]);