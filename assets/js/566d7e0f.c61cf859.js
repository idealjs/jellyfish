"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[863],{876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=h(n),p=i,u=m["".concat(l,".").concat(p)]||m[p]||d[p]||r;return n?a.createElement(u,s(s({ref:t},c),{},{components:n})):a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:i,s[1]=o;for(var h=2;h<r;h++)s[h]=n[h];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var a=n(7896),i=(n(2784),n(876));const r={},s="Asset IO",o={unversionedId:"Asset IO",id:"Asset IO",title:"Asset IO",description:"External assets are processed through the Asset Input-Output (IO) Engine pipeline and transformed into one or more engine-compatible assets.",source:"@site/docs/Asset IO.md",sourceDirName:".",slug:"/Asset IO",permalink:"/jellyfish/docs/Asset IO",draft:!1,editUrl:"https://github.com/idealjs/jellyfish/tree/main/packages/apps/website/docs/Asset IO.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",next:{title:"Audio",permalink:"/jellyfish/docs/Audio"}},l={},h=[{value:"About engine asset and its .meta file:",id:"about-engine-asset-and-its-meta-file",level:3},{value:"<strong>About the asset IO engine pipeline:</strong>",id:"about-the-asset-io-engine-pipeline",level:3},{value:"glTF reminder:",id:"gltf-reminder",level:3}],c={toc:h},m="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"asset-io"},"Asset IO"),(0,i.kt)("p",null,"External assets are processed through the Asset Input-Output (IO) Engine pipeline and transformed into one or more engine-compatible assets."),(0,i.kt)("p",null,"For instance, a glTF file can be converted into .texture, .animation, .skin, .mesh, and .material assets. If the glTF file includes embedded external files such as images, these images are treated as external assets and processed through the pipeline again."),(0,i.kt)("p",null,"After this conversion process, the original external asset remains unchanged in the folder. However, an additional .meta file is created, which contains corresponding engine-compatible asset data. This .meta file serves as the exclusive source for the engine to load assets into the runtime scene. Within the engine editor, the external asset is disregarded, and the .meta file is presented as an engine-recognized asset."),(0,i.kt)("h3",{id:"about-engine-asset-and-its-meta-file"},"About engine asset and its .meta file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},".gltf .meta file will be represented as a thumbnail of the model and the actual node structure referring to different separated engine assets like .png .texture, .mesh. These second level engine assets parsed from the gltf will become individual at their own, each has its own corresponding .meta asset"),(0,i.kt)("li",{parentName:"ul"},".png files are image files that are used as the source for textures. They contain the raw image data in a standard format that can be read by many different programs.","  The .png's .meta file contains the actual image data in a format that can be directly used by the GPU. This might be a compressed format to save memory, or it might be a raw format for maximum quality. The .meta file also contains metadata about the image, such as its dimensions and format (e.g., RGB, RGBA, etc.).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "width": 1024,\n    "height": 1024,\n    "format": "RGBA",\n    "imageData": "<binary data>"\n}\n'))),(0,i.kt)("li",{parentName:"ul"},".texture asset contains the configuration of the texture. This includes information such as the texture's dimensions, its format (e.g., RGB, RGBA, etc.), and any other settings that affect how the texture is used, such as its wrap mode (e.g., repeat, clamp to edge, etc.) and filter mode (e.g., linear, nearest, etc.).","  The .texture's .meta file does not contain the actual image data. Instead, it contains a reference to the .png's .meta file, which holds the actual image data. This allows the engine to separate the texture's configuration from its image data, providing more flexibility.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n        "width": 1024,\n        "height": 1024,\n        "format": "RGBA",\n        "wrapMode": "Repeat",\n        "filterMode": "Linear"\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "originalFile": "Example.png.meta"\n}\n'))),(0,i.kt)("li",{parentName:"ul"},".mesh asset contains the configuration of the mesh. This includes information such as the vertex attributes (e.g., positions, normals, texture coordinates, etc.), the indices that define the triangles of the mesh, and any other settings that affect how the mesh is rendered.","  The .mesh's .meta file contains the actual vertex and index data in a format that can be directly used by the GPU. This allows the engine to efficiently load the mesh data directly into the GPU's memory, without having to parse the .mesh file. The .meta file also contains metadata about the mesh, such as the number of vertices and indices, and the format of the vertex attributes.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "vertexAttributes": [\n        {"name": "position", "type": "vec3"},\n        {"name": "normal", "type": "vec3"},\n        {"name": "texCoord", "type": "vec2"}\n    ],\n    "indices": "Example.indices"\n}\n\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "vertexCount": 1024,\n    "indexCount": 2048,\n    "vertexData": "<binary data>",\n    "indexData": "<binary data>"\n}\n\n'))),(0,i.kt)("li",{parentName:"ul"},".animation asset contains the configuration of the animation. This includes information such as the duration of the animation, the frames per second (fps), and references to the animated properties (e.g., position, rotation, scale, etc.) of the objects.","  The .animation's .meta file contains the actual keyframe data in a format that can be directly used by the engine. This allows the engine to efficiently load the animation data and interpolate between keyframes during runtime. The .meta file also contains metadata about the animation, such as the number of keyframes, the timing of each keyframe, and the type of interpolation to be used (e.g., linear, bezier, etc.).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "duration": 10.0,\n    "fps": 30,\n    "animatedProperties": [\n        {"object": "Character", "property": "position"},\n        {"object": "Character", "property": "rotation"}\n    ]\n}\n\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n        "keyframeCount": 300,\n        "keyframeData": "<binary data>"\n}\n'))),(0,i.kt)("li",{parentName:"ul"},".skin asset contains the information about the skinning of the model. This includes the joint hierarchy, the bind pose matrices for each joint, and the weights that determine how much each joint influences each vertex of the mesh.","  The .skin's .meta file contains the actual skinning data in a format that can be directly used by the engine. This allows the engine to efficiently load the skinning data and apply it to the mesh during runtime. The .meta file also contains metadata about the skinning, such as the number of joints, the hierarchy of the joints, and the format of the weights.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "joints": [\n        {"name": "Root", "parent": null},\n        {"name": "Spine", "parent": "Root"},\n        {"name": "Head", "parent": "Spine"},\n        // More joints...\n    ],\n    "weights": "Example.weights"\n}\n\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n        "jointCount": 50,\n        "hierarchy": "<binary data>",\n        "bindPoses": "<binary data>",\n        "weights": "<binary data>"\n}\n'))),(0,i.kt)("li",{parentName:"ul"},".material asset contains the information about the appearance of the model, including the color, texture, and other surface properties. Its .meta file contains references to the textures used (which point to the .meta files of the .png or .texture files), as well as any other parameters needed to render the material, such as the type of shading model used (e.g., Phong, Lambertian, etc.)."),(0,i.kt)("li",{parentName:"ul"},".shader asset contains the shader program that is used to render the materials. This typically includes a vertex shader, which processes the vertices of the mesh, and a fragment shader, which processes the pixels of the rendered image. Depending on the complexity of the rendering pipeline, it might also include other types of shaders, such as geometry shaders, tessellation shaders, or compute shaders. The shader code is usually written in a shading language like GLSL or HLSL. The .shader's .meta file contains the compiled version of the shader code, which can be directly used by the GPU. This compilation process is usually done ahead of time to improve performance. The .meta file might also contain other information, such as the input and output variables of the shader, any constants or uniforms used, and the render states that should be set when using this shader.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-glsl"},"#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aNormal;\nlayout (location = 2) in vec2 aTexCoord;\n\nout vec2 TexCoord;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    gl_Position = projection * view * model * vec4(aPos, 1.0);\n    TexCoord = aTexCoord;\n}\n\n// Fragment Shader\n#version 330 core\nout vec4 FragColor;\n\nin vec2 TexCoord;\nuniform sampler2D texture_diffuse1;\n\nvoid main()\n{\n    FragColor = texture(texture_diffuse1, TexCoord);\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "shaderType": "GLSL",\n    "version": "330 core",\n    "inputs": [\n        {"name": "aPos", "type": "vec3", "location": 0},\n        {"name": "aNormal", "type": "vec3", "location": 1},\n        {"name": "aTexCoord", "type": "vec2", "location": 2}\n    ],\n    "outputs": [\n        {"name": "FragColor", "type": "vec4"}\n    ],\n    "uniforms": [\n        {"name": "model", "type": "mat4"},\n        {"name": "view", "type": "mat4"},\n        {"name": "projection", "type": "mat4"},\n        {"name": "texture_diffuse1", "type": "sampler2D"}\n    ],\n    "compiledCode": "<binary data>"\n}\n')))),(0,i.kt)("h3",{id:"about-the-asset-io-engine-pipeline"},(0,i.kt)("strong",{parentName:"h3"},"About the asset IO engine pipeline:")),(0,i.kt)("p",null,"The Asset IO Engine Pipeline is a fundamental component of a 3D engine. Its primary role is to transform external assets into a format that can be readily utilized by the engine. This transformation process involves parsing the original files, extracting necessary data, and subsequently storing this data in a new .meta file that the engine can interpret."),(0,i.kt)("p",null,"The pipeline operates as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Input"),": The pipeline accepts an external asset file (such as a .gltf or .png file) as its input."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Parsing"),": The pipeline parses the input file and extracts the necessary data. For instance, parsing a .gltf file might involve extracting mesh data, texture references, animations, and skinning information. For a .png file, the pipeline would read the image data. Any external model file will eventually be converted to .prefab and .meta files."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Prefab Creation"),": The .prefab file provides comprehensive details of the original glTF file, but in the form of an engine scene graph. This supports engine-specific features such as scripting. The .prefab and .scene files essentially share the same underlying structure."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Data Conversion"),": The extracted data is then transformed into a format that is friendly to the engine. This could involve converting image data into a specific texture format or transforming mesh data into a format that can be easily used by the engine's renderer."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Meta File Creation"),": The converted data is subsequently stored in a new .meta file. This file contains all the information the engine requires to use the asset, in a format that it can easily read and interpret."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Asset Loading"),": The .meta file is then used by the engine to load the asset into the runtime scene. The engine disregards the original external asset file; all it requires is the .meta file.")),(0,i.kt)("p",null,"This pipeline ensures that the engine can efficiently load and utilize assets, regardless of their original format. It also offers a high degree of flexibility, as the engine can support any asset format for which a parser can be written."),(0,i.kt)("h3",{id:"gltf-reminder"},"glTF reminder:"),(0,i.kt)("p",null,"Process GLTF resources into a unified engine input, converting mesh, material, animation, etc. into engine classes. Binary data doesn't need to be changed. At this stage, it should be implemented such that the engine classes can correctly access and parse binary block data. The entire engine uses the ECS (Entity Component System) model. All classes must have an index corresponding to the binary data, which is stored in a database. Only when the data exists in the database, can it be referenced by the corresponding class."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "primitives": [\n        {\n            "attributes": {\n                "POSITION": 0,\n                "NORMAL": 1,\n                "TEXCOORD_0": 2,\n                "TEXCOORD_1": 3,\n                "TANGENT": 4,\n                "COLOR_0": 5,\n                "JOINTS_0": 6,\n                "WEIGHTS_0": 7\n            },\n            "indices": 8,\n            "material": 0,\n            "mode": 4,\n            "targets": [\n                {\n                    "POSITION": 9,\n                    "NORMAL": 10,\n                    "TANGENT": 11\n                },\n                {\n                    "POSITION": 12,\n                    "NORMAL": 13,\n                    "TANGENT": 14\n                }\n            ]\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"Here, each key corresponds to the accessor index. The final data for ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"JOINTS_0"))," and ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"WEIGHTS_0"))," is in matrix form. The lengths of these two arrays should be consistent. The information carried by the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"JOINTS_0"))," matrix is the sequence number of the bone nodes affected by each primitive's vertex, which corresponds to the sequence number in the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"joints"))," array of the glTF's skin."),(0,i.kt)("p",null,"Breaking it down: A ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"primitive"))," corresponds to a file, equivalent to a 'mesh' in Unity. Each accessor's index will turn into an ID. The primitive itself also needs to have an ID for querying the path of the skin file in the glTF file. The 'skin' corresponds to a file where the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"joints"))," array in the skin is the sequence number of nodes in the glTF file. Therefore, the skin also needs an ID to query the corresponding glTF node graph. The 'mesh' corresponds to a file, which is a 'gameobject' in Unity. The mesh includes the ID of the primitive. This ID can query the corresponding mesh file path."))}d.isMDXComponent=!0}}]);